<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rezeptwerk</title>

    <link rel="manifest" href="manifest.json" />
    <link rel="stylesheet" href="styles/tokens.css" />
    <link rel="stylesheet" href="styles/base.css" />
    <link rel="stylesheet" href="styles/components.css" />
    <link rel="stylesheet" href="styles/views.css" />
    <link rel="icon" href="./favicon.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="./icon-180.png" />
  </head>

  <body>
    <header class="app-header">
      <div class="header-grid">
        <div class="header-row header-row--top">
          <button id="backBtn" class="badge badge-btn" type="button" title="ZurÃ¼ck" hidden>â†</button>

          <button id="vegan101HeaderBtn" class="badge badge-btn badge--gold" type="button" title="Vegan 101">ğŸŒ±</button>

          <span id="dirtyDot" class="badge badge-btn" title="Ungespeichert" hidden>â—</span>
          <button id="modeBadge" class="badge badge-btn" type="button" title="Speicher-Modus">â€”</button>
        </div>

        <div class="header-row header-row--bottom">
          <div class="header-space">
            <span class="header-space__icon" aria-hidden="true">ğŸ”€</span>
            <select id="headerSpaceSelect" class="badge badge-select badge--space" title="Space wÃ¤hlen"></select>
          </div>

          <div class="header-actions">
            <button id="radioHeaderBtn" class="badge badge-btn" type="button" title="Radio" hidden>ğŸ§</button>
            <button id="shopBadge" class="badge badge-btn" type="button" title="Einkaufsliste">ğŸ§º</button>

            <!-- neu: nur noch 1 Einstieg -->
            <button id="accountBtn" class="badge badge-btn badge--warn" type="button" title="Account / Einstellungen" hidden>ğŸ‘¤</button>
          </div>
        </div>
      </div>
    </header>

    <main id="app"></main>
    <div id="radioDockRoot"></div>

    <div id="globalTimersRoot" class="compact-mode"></div>

    <!-- Update Toast (single source of truth) -->
    <div id="updateToast" class="toast" role="status" aria-live="polite" aria-hidden="true">
      <div class="toast__text">
        <div class="toast__title">Update verfÃ¼gbar</div>
        <div class="toast__msg">Neue Version ist bereit. Neu laden?</div>
      </div>
      <div class="toast__actions">
        <button id="toastLater" class="btn btn-ghost" type="button">SpÃ¤ter</button>
        <button id="toastReload" class="btn btn-primary" type="button">Neu laden</button>
      </div>
    </div>

  <script type="module" src="./src/entry.js"></script>

    <script>
      // Service Worker: App-Shell Cache + Update-Toast (priorisiert, kein Reload wÃ¤hrend aktiver Timer)
      // DEV: disable SW to avoid stale CSS/JS (no hard refresh needed)
      const IS_DEV_HOST = location.hostname === "localhost" || location.hostname === "127.0.0.1";

      if (IS_DEV_HOST) {
        if ("serviceWorker" in navigator) {
          navigator.serviceWorker.getRegistrations?.().then((regs) => regs.forEach((r) => r.unregister()));
        }
      } else if ("serviceWorker" in navigator) {
        window.addEventListener("load", async () => {
          const toast = document.getElementById("updateToast");
          const btnLater = document.getElementById("toastLater");
          const btnReload = document.getElementById("toastReload");

          const hasActiveTimers = () => {
            try {
              // Timer-Store wird von domain/timers.js genutzt
              const raw = localStorage.getItem("tinkeroneo_timers_v1") || "[]";
              const timers = JSON.parse(raw);
              return (
                Array.isArray(timers) &&
                timers.some((t) => (t?.remainingSec ?? 0) > 0 || (t?.endAt ?? 0) > Date.now())
              );
            } catch {
              return false;
            }
          };

          const inCookView = () => {
            try {
              return (location.hash || "").startsWith("#cook");
            } catch {
              return false;
            }
          };

          const showToast = () => {
            if (!toast) return;
            // Priorisierung: kein Update-Toast wÃ¤hrend aktiver Timer oder im Kochmodus
            if (hasActiveTimers() || inCookView()) {
              // retry spÃ¤ter
              window.clearTimeout(window.__updateToastRetry);
              window.__updateToastRetry = window.setTimeout(showToast, 2500);
              return;
            }
            toast.classList.add("toast--show");
            toast.setAttribute("aria-hidden", "false");
          };

          const hideToast = () => {
            if (!toast) return;
            toast.classList.remove("toast--show");
            toast.setAttribute("aria-hidden", "true");
          };

          try {
            const reg = await navigator.serviceWorker.register("./sw.js");

            const requestSkipWaiting = () => {
              if (reg.waiting) {
                reg.waiting.postMessage({ type: "SKIP_WAITING" });
              }
            };

            // Buttons
            btnLater?.addEventListener("click", hideToast);
            btnReload?.addEventListener("click", () => {
              hideToast();
              requestSkipWaiting();
            });

            // Wenn ein Update gefunden & installiert wird: Toast anzeigen (statt sofort reload)
            reg.addEventListener("updatefound", () => {
              const sw = reg.installing;
              if (!sw) return;
              sw.addEventListener("statechange", () => {
                if (sw.state === "installed") {
                  // installed + controller vorhanden => Update bereit
                  if (navigator.serviceWorker.controller) {
                    showToast();
                  }
                }
              });
            });

            // Falls schon waiting (z.B. Tab lange offen)
            if (reg.waiting && navigator.serviceWorker.controller) {
              showToast();
            }

            // Sobald der neue SW die Kontrolle Ã¼bernimmt: reload
            let reloaded = false;
            navigator.serviceWorker.addEventListener("controllerchange", () => {
              if (reloaded) return;
              reloaded = true;
              window.location.reload();
            });

            // optional: gelegentlich nach Updates schauen
            setInterval(() => reg.update(), 60 * 60 * 1000);
          } catch {
            // offline/blocked => ok
          }
        });
      }
    </script>
  </body>
</html>
